###
#takes list of variable input and returns a list with models and AIC values
fit_model <- function(variables, X, y, model_type) {
  #model with one or more predictors
  formula_str <- paste("y ~", paste(variables, collapse = " + "))
  formula_obj <- as.formula(formula_str)
  if (model_type == "linear") {
    model <- lm(formula_obj, data = X)
  } else {
    model <- glm(formula_obj, data = X, family = binomial)
  }
  return(list(model = model, aic = AIC(model)))
}

###
#builds empty model and returns a list with models and AIC values
fit_empty_model <- function(y, model_type){
  #empty model
  if (model_type == "linear") {
    model <- lm(y ~ 1)
  } else {
    model <- glm(y ~ 1, family = binomial)
  }
  return(list(model = model, aic = AIC(model)))
}

###
#create unique model identifier
model_id <- function(variables) {
  if (length(variables) == 0) return("intercept_only")
  paste(sort(variables), collapse = "+")
}

###
# X (data frame of predictors)
# y (vector of responses)
# model_type (linear or logistic)
# K (number of steps / max model size)
# e (minimum AIC improvement - epsilon)
# sig (tolerance for keeping near-ties - delta)
# L (optional limit on how many models to keep per step)
build_paths <- function(X, y, model_type, K, e, delta, L = NULL) {
  
  #convert X to data frame and get variable names
  X <- as.data.frame(X)
  var_names <- colnames(X)
  if (is.null(var_names)) {
    var_names <- paste0("X", 1:ncol(X))
    colnames(X) <- var_names
  }
  
  #initialize
  frontiers <- list()  # Store models at each step
  aic_by_model <- list()  # Cache AIC values
  
  #start with empty model S_0
  S_0 <- fit_empty_model(y, model_type)
  frontiers[[1]] <- data.frame(
    step = 0,
    variables = I(list(character(0))),  # Empty character vector
    aic = S_0$aic,
    model_id = model_id(character(0)),
    stringsAsFactors = FALSE
  )
  aic_by_model[[model_id(character(0))]] <- S_0$aic
  parent_best_aic <- S_0$aic
  
  #repeat for max iteration count K
  for (k in 1:K) {
    #get parent models from previous step
    parent_models <- frontiers[[k]]
    candidate_children <- list()
    
    #for each parent model
    for (i in 1:nrow(parent_models)) {
      parent_vars <- parent_models$variables[[i]]
      parent_aic <- parent_models$aic[i]
      
      #get available variables to add
      available_vars <- setdiff(var_names, parent_vars)
      
      if (length(available_vars) == 0) next  # No more variables to add
      
      #create child models by adding each available variable
      child_aics <- numeric(length(available_vars))
      
      for (j in seq_along(available_vars)) {
        #create child by adding one variable
        child_vars <- c(parent_vars, available_vars[j])
        child_id <- model_id(child_vars)
        
        #check if already computed (avoid refitting)
        if (child_id %in% names(aic_by_model)) {
          child_aics[j] <- aic_by_model[[child_id]]
        } else {
          #fit new model and compute AIC
          result <- fit_model(child_vars, X, y, model_type)
          child_aics[j] <- result$aic
          aic_by_model[[child_id]] <- result$aic
        }
      }
      
      #find best child AIC for this parent
      best_child_aic <- min(child_aics)
      
      #keep children within delta of best and that improve by at least e
      for (j in seq_along(available_vars)) {
        aic_improvement <- parent_aic - child_aics[j]
        within_delta <- (child_aics[j] - best_child_aic) <= delta
        improves_enough <- aic_improvement >= e
        
        if (within_delta && improves_enough) {
          child_vars <- c(parent_vars, available_vars[j])
          candidate_children[[length(candidate_children) + 1]] <- list(
            variables = child_vars,
            aic = child_aics[j],
            model_id = model_id(child_vars),
            parent_id = parent_models$model_id[i]
          )
        }
      }
    }
    
    #check if any children were created
    if (length(candidate_children) == 0) {
      break  # Stop if no improvements found
    }
    
    #convert to data frame
    children_df <- data.frame(
      step = k,
      variables = I(lapply(candidate_children, function(x) x$variables)),
      aic = sapply(candidate_children, function(x) x$aic),
      model_id = sapply(candidate_children, function(x) x$model_id),
      parent_id = sapply(candidate_children, function(x) x$parent_id),
      stringsAsFactors = FALSE
    )
    
    #remove duplicates
    children_df <- children_df[!duplicated(children_df$model_id), ]
    
    #check if best child improves overall by at least e
    current_best_aic <- min(children_df$aic)
    if ((parent_best_aic - current_best_aic) < e) {
      break  # Stop if not enough improvement
    }
    
    #if too many models, keep only best L by AIC
    if (!is.null(L) && nrow(children_df) > L) {
      children_df <- children_df[order(children_df$aic)[1:L], ]
    }
    
    #store this frontier
    frontiers[[k + 1]] <- children_df
    parent_best_aic <- current_best_aic
  }
  
  #prepare output
  path_forest <- list(
    frontiers = frontiers,
    aic_by_model = aic_by_model,
    meta = list(
      model_type = model_type,
      K = K,
      eps = e,
      delta = delta,
      L = L,
      n_steps = length(frontiers) - 1,
      n_vars = length(var_names),
      var_names = var_names,
      total_models_explored = length(aic_by_model)
    )
  )
  return(path_forest)
}

